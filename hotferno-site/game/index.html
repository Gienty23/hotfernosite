<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>HOTFERNO Mini Game (Test)</title>
  <style>
    :root{
      --bg:#0b1220;
      --card:#121b2f;
      --card2:#0f172a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --accent:#f97316;
      --danger:#ef4444;
      --ok:#22c55e;
      --border:rgba(255,255,255,.10);
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:16px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      background: radial-gradient(900px 500px at 30% 0%, #1f2a44 0%, var(--bg) 60%);
      color:var(--text);
    }
    .wrap{max-width:1100px;margin:0 auto;display:grid;gap:12px}
    .top{
      display:flex; gap:12px; align-items:center; flex-wrap:wrap;
      padding:12px; border:1px solid var(--border); border-radius:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }
    .top h1{font-size:16px;margin:0 12px 0 0;color:#fff;letter-spacing:.5px}
    .btn{
      background:rgba(255,255,255,.06);
      border:1px solid var(--border);
      color:var(--text);
      padding:8px 12px; border-radius:12px;
      cursor:pointer;
      transition:transform .05s ease;
      user-select:none;
    }
    .btn:hover{border-color:rgba(255,255,255,.18)}
    .btn:active{transform:scale(.98)}
    .btn.primary{background:rgba(249,115,22,.14); border-color:rgba(249,115,22,.35)}
    .pill{
      padding:6px 10px;border-radius:999px;border:1px solid var(--border);
      background:rgba(255,255,255,.04); color:var(--muted); font-size:12px;
    }
    .pill b{color:#fff}
    .grid{
      display:grid; gap:12px;
      grid-template-columns: 1.2fr .8fr;
    }
    @media (max-width: 900px){
      .grid{grid-template-columns: 1fr}
    }

    .boardCard, .sideCard{
      border:1px solid var(--border);
      border-radius:16px;
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      overflow:hidden;
    }
    .cardHeader{
      padding:12px 14px;
      display:flex; justify-content:space-between; align-items:center; gap:8px;
      border-bottom:1px solid var(--border);
      background:rgba(0,0,0,.12);
    }
    .cardHeader .title{font-weight:700}
    .cardHeader .sub{color:var(--muted); font-size:12px}

    /* board */
    .board{
      position:relative;
      width:100%;
      aspect-ratio: 16/10;
      min-height: 360px;

      /* background image + dark overlay */
      background:
        linear-gradient(180deg, rgba(10,15,25,.82), rgba(10,15,25,.92)),
        url("/pic/shaoniao.jpg");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    /* frosted layer */
    .board::after{
      content:"";
      position:absolute;
      inset:0;
      background: rgba(0,0,0,.18);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      pointer-events:none;
      z-index: 1;
    }

    .tile{
      position:absolute;
      width:58px;
      height:58px;
      border-radius:14px;

      /* Mahjong-like solid piece (opaque) */
      background: #f8fafc;
      border: 1px solid rgba(255,255,255,.55);

      /* subtle 3D rim */
      box-shadow:
        0 10px 18px rgba(0,0,0,.38),
        inset 0 0 0 2px rgba(16,185,129,.35),   /* green edge hint */
        inset 0 -10px 18px rgba(0,0,0,.10);

      display:flex;
      align-items:center;
      justify-content:center;

      cursor:pointer;
      user-select:none;
      -webkit-user-drag:none;
      overflow:hidden;
      opacity:1;
    }
    .tile::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:14px;
      /* top highlight */
      background: linear-gradient(180deg, rgba(255,255,255,.55), rgba(255,255,255,0) 55%);
      pointer-events:none;
      opacity:.55;
    }
    .tile .icon{
      position:relative;
      z-index:2;
      font-size:30px;
      line-height:1;
      transform: translateY(-1px);
      text-shadow: 0 2px 0 rgba(0,0,0,.10);
    }
    .tile.disabled{
      opacity:1;            /* keep fully opaque like ç¾Šäº†ä¸ªç¾Š */
      cursor:not-allowed;
      filter:none;          /* do not gray out */
    }

    /* tray */
    .trayWrap{padding:12px 14px; display:grid; gap:10px}
    .tray{
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      gap:8px;
    }
    .slot{
      height:56px; border-radius:14px;
      border:1px dashed rgba(255,255,255,.20);
      background: rgba(255,255,255,.03);
      display:flex; align-items:center; justify-content:center;
      font-size:22px; position:relative;
    }
    .slot.filled{
      border-style:solid;
      background: rgba(255,255,255,.06);
    }
    .note{color:var(--muted);font-size:12px;line-height:1.5}
    .log{
      padding:10px 12px; border-radius:14px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.15);
      color: var(--muted);
      font-size:12px;
      min-height: 56px;
    }
    .log b{color:#fff}
    .status{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      padding:12px 14px;
      border-top:1px solid var(--border);
      background: rgba(0,0,0,.10);
    }
    .status .msg{flex:1;color:var(--muted); font-size:13px}
    .status .msg strong{color:#fff}
    .badge{
      padding:6px 10px; border-radius:999px; font-size:12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
    }
    .badge.ok{border-color:rgba(34,197,94,.4); background:rgba(34,197,94,.10)}
    .badge.danger{border-color:rgba(239,68,68,.4); background:rgba(239,68,68,.10)}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      padding:2px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color:#fff; font-size:12px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <h1>HOTFERNO Mini Game</h1>
      <button class="btn primary" id="btnL1">Start</button>      <button class="btn" id="btnRestart">é‡å¼€æœ¬å…³</button>
      <span class="pill">è§„åˆ™ï¼šç‚¹ç‰Œè¿›æ§½ï¼Œ<b>åŒå›¾æ ‡ 3 ä¸ª</b>è‡ªåŠ¨æ¶ˆé™¤ï¼›æ§½æœ€å¤š <b>7</b> æ ¼ï¼Œæ»¡äº†å°±å¤±è´¥</span>
      <span class="pill">å¿«æ·é”®ï¼š<span class="kbd">R</span> é‡å¼€</span>
    </div>

    <div class="grid">
      <div class="boardCard">
        <div class="cardHeader">
          <div>
            <div class="title" id="levelTitle">Not started</div>
            <div class="sub" id="levelSub">Click Start to begin</div>
          </div>
          <div class="pill">å‰©ä½™ï¼š<b id="remainCount">0</b></div>
        </div>
        <div class="board" id="board"></div>
        <div class="status">
          <div class="msg" id="msg">Ready.</div>
          <div class="badge" id="badge">â€”</div>
        </div>
      </div>

      <div class="sideCard">
        <div class="cardHeader">
          <div>
            <div class="title">æš‚å­˜æ§½</div>
            <div class="sub">æ»¡ 7 æ ¼ä¸”æ— æ³•æ¶ˆé™¤å°±å¤±è´¥</div>
          </div>
          <div class="pill">æ§½ä½ï¼š<b id="trayCount">0</b>/7</div>
        </div>

        <div class="trayWrap">
          <div class="tray" id="tray"></div>
          <div class="log" id="log">
            æç¤ºï¼šLevel 2 is intentionally brutal â€” youâ€™ll often be one tile short.
          </div>
          <div class="note">
            è¯´æ˜ï¼šæœ¬åœ°ç‰ˆå·²æ¢æˆæ—¥å¼é£æ ¼ emoji åšå ä½ï¼ˆğŸ¢ğŸ®ğŸ—»ğŸ¶ğŸºğŸœğŸ™ğŸŒ¸â›©ï¸ğŸ”¥ğŸ¥¢ğŸ±ï¼‰ã€‚<br/>
            ä¹‹åä¸Šçº¿å†æ¢æˆä½ çš„å“ç‰Œå›¾æ ‡/é£Ÿç‰©å›¾æ ‡ï¼Œå¹¶æ¥â€œå…‘æ¢ç +æ’è¡Œæ¦œâ€åç«¯ã€‚
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const ICONS = ["ğŸ¢","ğŸ®","ğŸ—»","ğŸ¶","ğŸº","ğŸœ","ğŸ™","ğŸŒ¸","â›©ï¸","ğŸ”¥","ğŸ¥¢","ğŸ±"];
  const boardEl = document.getElementById("board");
  const trayEl = document.getElementById("tray");
  const logEl = document.getElementById("log");
  const msgEl = document.getElementById("msg");
  const badgeEl = document.getElementById("badge");
  const remainEl = document.getElementById("remainCount");
  const trayCountEl = document.getElementById("trayCount");
  const levelTitleEl = document.getElementById("levelTitle");
  const levelSubEl = document.getElementById("levelSub");

  const btnL1 = document.getElementById("btnL1");  const btnRestart = document.getElementById("btnRestart");

  // ====== æ¸¸æˆçŠ¶æ€ ======
  let state = {
    level: 0,
    types: 6,
    gridW: 10,
    gridH: 6,
    // stacks[x][y] = [tileId... bottom->top]
    stacks: [],
    tiles: new Map(), // id -> {id,type,x,y,z,removed}
    tray: [], // tileId list in order
    playing: false,
    result: null, // "win" | "lose" | null
  };

  function setBadge(kind, text){
    badgeEl.className = "badge" + (kind ? (" " + kind) : "");
    badgeEl.textContent = text;
  }
  function setMsg(html){
    msgEl.innerHTML = html;
  }
  function log(html){
    logEl.innerHTML = html;
  }

  function initTrayUI(){
    trayEl.innerHTML = "";
    for(let i=0;i<7;i++){
      const slot = document.createElement("div");
      slot.className = "slot";
      slot.dataset.idx = i;
      trayEl.appendChild(slot);
    }
    renderTray();
  }

  function renderTray(){
    const slots = trayEl.querySelectorAll(".slot");
    slots.forEach((s,i)=>{
      const tileId = state.tray[i];
      if(tileId == null){
        s.classList.remove("filled");
        s.textContent = "";
      } else {
        s.classList.add("filled");
        const t = state.tiles.get(tileId);
        s.textContent = ICONS[t.type];
      }
    });
    trayCountEl.textContent = `${state.tray.length}/7`;
  }

  function createEmptyStacks(){
    state.stacks = Array.from({length: state.gridW}, () =>
      Array.from({length: state.gridH}, () => [])
    );
  }

  // ====== å…³å¡ç”Ÿæˆï¼ˆåŸåˆ›è§„åˆ™ï¼šåªæ˜¯â€œåƒâ€ï¼Œä¸æ˜¯å¤åˆ»ï¼‰ ======
  // ç®€åŒ–ï¼šæ¯ä¸ªæ ¼å­æ˜¯ä¸€ä¸ªâ€œå å †â€ï¼Œåªèƒ½ç‚¹æœ€é¡¶å±‚ï¼ˆæ›´åƒâ€œé®æŒ¡â€ï¼‰
  // Level 1: 4 types, 24 tiles, stack depth <=2
  // Level 2: 6 types, 54 tiles, stack depth <=4, trap distribution
  function startLevel(level){
    state.level = level;
    state.result = null;
    state.playing = true;
    state.tray = [];
    state.tiles = new Map();
    createEmptyStacks();

    const cfg = (level === 1)
      ? { types: 4, total: 24,  maxDepth: 2, label: "Level 1 (Easy)", sub:"Few tiles, light blocking â€” you should clear it." }
      : { types: 12, total: 120, maxDepth: 6, label: "Level 2 (Brutal)", sub:"More types, deeper stacks, trap distribution â€” extremely hard." };

    state.types = cfg.types;

    levelTitleEl.textContent = cfg.label;
    levelSubEl.textContent = cfg.sub;

    initTrayUI();
    generateTiles(cfg);
    renderBoard();

    setBadge("", "è¿›è¡Œä¸­");
    setMsg(`Playing <strong>${cfg.label}</strong>. Tap a top tile to move it to the tray. <strong>3 of the same icon</strong> clears automatically.`);
    log(`æç¤ºï¼šå¦‚æœä½ æƒ³è®©ç¬¬2å…³æ›´éš¾ï¼Œåé¢æˆ‘ä»¬å¯ä»¥æŠŠæ§½ä» 7 æ”¹åˆ° 6ï¼ˆä½†å»ºè®®å…ˆç”¨ 7ï¼‰ã€‚`);
    updateRemain();
  }

  function generateTiles(cfg){
    // è®© total ä¸€å®šæ˜¯ 3 çš„å€æ•°ï¼ˆæ¶ˆé™¤è§„åˆ™éœ€è¦ï¼‰
    let total = cfg.total - (cfg.total % 3);
    if(total < 12) total = 12;

    // 1) å…ˆç”Ÿæˆ type åºåˆ—ï¼ˆæ¯ç§å‡ºç°æ¬¡æ•°æ˜¯ 3 çš„å€æ•°ï¼‰
    // Level 1ï¼šå‡åŒ€åˆ†é…
    // Level 2ï¼šåšâ€œé™·é˜±â€ï¼šæŸä¸¤ç§ç±»å‹åœ¨é¡¶å±‚å¾ˆå°‘å‡ºç°ï¼Œç¬¬ä¸‰ä¸ªä¼šåŸ‹å¾—å¾ˆæ·±
    const typeCounts = new Array(cfg.types).fill(0);

    if(state.level === 1){
      // å‡åŒ€
      for(let i=0;i<total;i++){
        typeCounts[i % cfg.types]++;
      }
    } else {
      // é™·é˜±ï¼šè®© 0 å’Œ 1 ç±»å‹æ›´â€œé˜´é™©â€
      // å¤§è‡´åˆ†å¸ƒï¼šä¸¤ç§ç±»å‹æ›´ååº•å±‚å‡ºç°
      // å…ˆå‡åŒ€
      for(let i=0;i<total;i++) typeCounts[i % cfg.types]++;
      // è°ƒæ•´ï¼šæŠŠä¸€äº›æ•°é‡ä» 0/1 æŒªåˆ°å…¶ä»–ç±»å‹ï¼ˆä¿æŒæ€»æ•°ä¸å˜ï¼‰
      // ç›®çš„ï¼šè®© 0/1 åœ¨â€œå¯ç‚¹å‡»çš„æ—©æœŸâ€æ›´éš¾å‡‘é½
      // ï¼ˆè¿™é‡Œç”¨â€œåŸ‹æ·±ç­–ç•¥â€æ¥å®ç°ï¼Œæ•°é‡ä»ä¿æŒå¯æ¶ˆï¼‰
    }

    // 2) åˆ›å»º tile åˆ—è¡¨ï¼ˆå…ˆæŒ‰ç±»å‹å¡«å……ï¼‰
    const tileList = [];
    for(let type=0; type<cfg.types; type++){
      // æŠŠ counts è°ƒæˆ 3 çš„å€æ•°
      const c = typeCounts[type] - (typeCounts[type] % 3);
      typeCounts[type] = c;
      for(let k=0;k<c;k++) tileList.push(type);
    }

    // å¦‚æœå› ä¸ºå–æ•´å¯¼è‡´å°‘äº†ï¼Œè¡¥åˆ° totalï¼ˆä¾ç„¶ä¿è¯ 3 çš„å€æ•°ï¼‰
    while(tileList.length < total){
      const type = tileList.length % cfg.types;
      // ä¸€æ¬¡è¡¥3ä¸ª
      tileList.push(type, type, type);
    }
    tileList.length = total;

    // æ‰“ä¹±
    shuffle(tileList);

    // 3) æŠŠ tiles æ”¾åˆ° stacks é‡Œ
    // ä½ç½®ç­–ç•¥ï¼š
    // - Level 1ï¼šéšæœºæ’’åœ¨æ›´å¤šæ ¼å­ä¸Šï¼Œæ·±åº¦æµ…
    // - Level 2ï¼šé›†ä¸­åœ¨è¾ƒå°‘æ ¼å­ä¸Šï¼Œæ·±åº¦æ·±ï¼ˆæ›´å®¹æ˜“å¡æ§½ï¼‰
    const cells = [];
    for(let x=0;x<state.gridW;x++){
      for(let y=0;y<state.gridH;y++){
        cells.push([x,y]);
      }
    }
    shuffle(cells);

    const useCellCount = (state.level === 1) ? Math.floor(cells.length * 0.75) : Math.floor(cells.length * 0.45);
    const activeCells = cells.slice(0, useCellCount);

    let idSeq = 1;

    if(state.level === 2){
      // Level 2 åŸ‹æ·±ç­–ç•¥ï¼š
      // - type 0/1ï¼šå°½é‡æ”¾åœ¨æ›´æ·±å±‚ï¼ˆå…ˆæŠŠå…¶ä»–ç±»å‹å¡«åˆ°æµ…å±‚ï¼‰
      const t01 = tileList.filter(t => t===0 || t===1);
      const others = tileList.filter(t => t!==0 && t!==1);
      shuffle(t01); shuffle(others);

      // å…ˆé“ºæµ…å±‚ï¼šothers ä¼˜å…ˆ
      let idxOthers = 0, idxT01 = 0;

      // ç›®æ ‡ï¼šå°½é‡è®©å‰ ~40% çš„â€œé¡¶å±‚ç‰Œâ€å¾ˆå°‘å‡ºç° 0/1
      // åšæ³•ï¼šå…ˆæŠŠæ¯ä¸ª cell çš„ç¬¬ 1 å±‚ç”¨ others å¡«æ»¡ï¼Œå†å¼€å§‹å¡ t01 åˆ°æ›´æ·±
      // å®é™…å®ç°ï¼šå¾ªç¯æ”¾ç‰Œï¼Œä¼˜å…ˆé€‰æ‹©â€œå°šæœªè¾¾åˆ° maxDepth çš„ cellâ€ï¼Œå¹¶æŒ‰å½“å‰æ·±åº¦æ’åº
      const allTypes = {others, t01};
      const totalN = tileList.length;

      for(let n=0;n<totalN;n++){
        // é€‰ä¸€ä¸ª cellï¼šä¼˜å…ˆæµ…çš„
        const candidate = activeCells
          .filter(([x,y]) => state.stacks[x][y].length < cfg.maxDepth);
        candidate.sort((a,b)=> state.stacks[a[0]][a[1]].length - state.stacks[b[0]][b[1]].length);
        const [cx,cy] = candidate[Math.floor(Math.random() * Math.min(candidate.length, 10))];

        const depth = state.stacks[cx][cy].length;

        let type;
        // depth 0/1 ä¼˜å…ˆç”¨ others
        if(depth <= 1){
          if(idxOthers < others.length) type = others[idxOthers++];
          else type = t01[idxT01++]; // ä¸‡ä¸€ä¸å¤Ÿäº†
        } else {
          // æ·±å±‚æ›´å®¹æ˜“æ”¾ t01
          if(idxT01 < t01.length && Math.random() < 0.65) type = t01[idxT01++];
          else type = (idxOthers < others.length) ? others[idxOthers++] : t01[idxT01++];
        }

        const tid = idSeq++;
        const z = depth; // 0 bottom
        state.tiles.set(tid, {id: tid, type, x: cx, y: cy, z, removed:false});
        state.stacks[cx][cy].push(tid);
      }
    } else {
      // Level 1ï¼šæ™®é€šéšæœºå †å 
      for(const type of tileList){
        const candidates = activeCells.filter(([x,y]) => state.stacks[x][y].length < cfg.maxDepth);
        const [cx,cy] = candidates[Math.floor(Math.random() * candidates.length)];
        const depth = state.stacks[cx][cy].length;
        const tid = idSeq++;
        state.tiles.set(tid, {id: tid, type, x: cx, y: cy, z: depth, removed:false});
        state.stacks[cx][cy].push(tid);
      }
    }
  }

  // ====== æ¸²æŸ“ ======
  function renderBoard(){
    boardEl.innerHTML = "";

    const rect = boardEl.getBoundingClientRect();
    const bw = rect.width;
    const bh = rect.height;

    const paddingX = 22;
    const paddingY = 22;

    // æ ¼å­é—´è·ï¼šè®©ç‰Œçœ‹èµ·æ¥åˆ†å¸ƒåˆç†
    const cellW = (bw - paddingX*2) / state.gridW;
    const cellH = (bh - paddingY*2) / state.gridH;

    // ç”»æ¯ä¸ªæ ¼å­çš„â€œé¡¶å±‚ç‰Œâ€ï¼ˆæ‰€æœ‰å±‚éƒ½ä¼šæ¸²æŸ“ï¼Œä½†åªæœ‰é¡¶å±‚å¯ç‚¹ï¼‰
    for(let x=0;x<state.gridW;x++){
      for(let y=0;y<state.gridH;y++){
        const stack = state.stacks[x][y];
        if(stack.length === 0) continue;

        // æŒ‰å±‚æ¸²æŸ“ï¼ˆåº•->é¡¶ï¼‰ï¼Œåšä¸ªâ€œå å±‚åç§»â€è§†è§‰
        for(let i=0;i<stack.length;i++){
          const tid = stack[i];
          const t = state.tiles.get(tid);
          if(!t || t.removed) continue;

          const div = document.createElement("div");
          div.className = "tile";
          div.dataset.id = String(tid);

          // ä½ç½®ï¼šæ ¼å­ä¸­å¿ƒ + å å±‚åç§»
          const baseX = paddingX + x*cellW + cellW*0.5;
          const baseY = paddingY + y*cellH + cellH*0.5;

          // å å±‚åç§»ï¼šè¶Šé«˜è¶Šå¾€å³ä¸Šï¼Œå¢å¼ºé®æŒ¡æ„Ÿ
          const offset = i * 6;
          const left = baseX - 32 + offset;
          const top  = baseY - 32 - offset;

          div.style.left = `${left}px`;
          div.style.top = `${top}px`;
          div.style.zIndex = String(10 + i);

          div.textContent = ICONS[t.type];
          const isTop = (i === stack.length - 1);
          if(!isTop || !state.playing){
            div.classList.add("disabled");
          } else {
            div.addEventListener("click", () => onPick(tid), {passive:true});
          }

          boardEl.appendChild(div);
        }
      }
    }

    updateRemain();
  }

  function updateRemain(){
    let remain = 0;
    for(const t of state.tiles.values()){
      if(!t.removed) remain++;
    }
    remainEl.textContent = String(remain);
    if(state.playing && remain === 0 && state.tray.length === 0){
      win();
    }
  }

  // ====== äº¤äº’ä¸è§„åˆ™ ======
  function onPick(tileId){
    if(!state.playing) return;
    if(state.tray.length >= 7){
      lose("æš‚å­˜æ§½å·²æ»¡ï¼Œæ— æ³•ç»§ç»­æ”¾å…¥ã€‚");
      return;
    }

    const t = state.tiles.get(tileId);
    if(!t || t.removed) return;

    // å¿…é¡»æ˜¯è¯¥æ ¼å­é¡¶å±‚
    const stack = state.stacks[t.x][t.y];
    const topId = stack[stack.length - 1];
    if(topId !== tileId) return;

    // ä» stack å¼¹å‡º
    stack.pop();
    t.removed = true;

    // æ”¾å…¥ tray
    state.tray.push(tileId);
    renderTray();

    // å¤„ç†æ¶ˆé™¤ï¼šåŒç±»å‹ 3 ä¸ª
    const type = t.type;
    const idxs = [];
    for(let i=0;i<state.tray.length;i++){
      const tid = state.tray[i];
      const tt = state.tiles.get(tid);
      if(tt && tt.type === type) idxs.push(i);
    }
    if(idxs.length >= 3){
      // åˆ é™¤æœ€æ—©çš„ 3 ä¸ªï¼ˆæ›´ç¬¦åˆâ€œæ‰‹æ„Ÿâ€ï¼‰
      const toRemove = idxs.slice(0,3).sort((a,b)=>b-a);
      for(const idx of toRemove){
        state.tray.splice(idx,1);
      }
      renderTray();
      setMsg(`æ¶ˆé™¤äº† <strong>${ICONS[type]}</strong> Ã— 3ï¼ç»§ç»­ï¼`);
      setBadge("ok", "è¿æ¶ˆ +1");
    } else {
      setMsg(`å·²æ”¾å…¥ <strong>${ICONS[type]}</strong>ã€‚å‡‘é½ 3 ä¸ªå³å¯æ¶ˆé™¤ã€‚`);
      setBadge("", "è¿›è¡Œä¸­");
    }

    // å¤±è´¥åˆ¤å®šï¼šæ§½æ»¡ä¸”æ— æ³•å†äº§ç”Ÿæ¶ˆé™¤çš„æƒ…å†µä¸‹ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºï¼šæ§½æ»¡ç«‹å³å¤±è´¥ï¼‰
    if(state.tray.length >= 7){
      lose("æš‚å­˜æ§½æ»¡ 7 æ ¼ï¼ŒæŒ‘æˆ˜å¤±è´¥ã€‚");
      return;
    }

    // é‡æ–°æ¸²æŸ“å¯ç‚¹çŠ¶æ€
    renderBoard();
  }

  function win(){
    state.playing = false;
    state.result = "win";
    setBadge("ok", "Cleared");

    // Level 1 -> proceed to Level 2 (no level selection)
    if(state.level === 1){
      setMsg(`ğŸ‰ <strong>Level 1 cleared!</strong><br/>
        <button class="btn primary" id="btnNext" style="margin-top:10px;">Continue to Level 2</button>
      `);
      log(`<b>Nice.</b> Level 2 is where it gets brutal. Good luck.`);
      renderBoard();

      setTimeout(()=>{
        const btnNext = document.getElementById("btnNext");
        if(btnNext){
          btnNext.addEventListener("click", ()=> startLevel(2));
        } else {
          setTimeout(()=> startLevel(2), 1500);
        }
      }, 0);
      return;
    }

    // Level 2 -> final win
    setMsg(`ğŸ† <strong>Level 2 cleared!</strong><br/>Show this win screen in-store to claim your reward (testing).`);
    log(`<b>Next (production)</b>: ask for nickname â†’ generate redeem code â†’ leaderboard â†’ staff redemption page.`);
    renderBoard();
  }

  function lose(reason){
    state.playing = false;
    state.result = "lose";
    setBadge("danger", "å¤±è´¥");
    setMsg(`ğŸ˜µ <strong>å¤±è´¥ï¼š</strong>${reason} ç‚¹å‡»â€œé‡å¼€æœ¬å…³â€å†æ¥ã€‚`);
    log(`<b>å¤±è´¥åŸå› </b>ï¼š${reason}<br/>ç¬¬2å…³çš„â€œé™·é˜±åˆ†å¸ƒâ€ä¼šè®©ä½ ç»å¸¸å·®ä¸€ä¸ªå‡‘ä¸é½ï¼Œè¿™æ˜¯æ­£å¸¸çš„ã€‚`);
    renderBoard();
  }

  // ====== å·¥å…· ======
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  // ====== äº‹ä»¶ç»‘å®š ======
  btnL1.addEventListener("click", ()=> startLevel(1));
btnRestart.addEventListener("click", ()=> {
    if(state.level === 2) startLevel(2);
    else startLevel(1);
  });window.addEventListener("keydown", (e)=>{
    if(e.key.toLowerCase()==="r"){
      btnRestart.click();
    }
  });

  // åˆå§‹åŒ– UI
  initTrayUI();
  setBadge("", "â€”");
})();
</script>
</body>
</html>

